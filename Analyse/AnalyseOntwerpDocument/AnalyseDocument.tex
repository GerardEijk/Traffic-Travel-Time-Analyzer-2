%Preambule met standaardinstellingen
\documentclass[ps,a4paper,oneside]{report}
%Noot: zorg ervoor dat Nederlandse woordsplitsing geactiveerd is.
\usepackage[dutch]{babel}
% Noot: je kan het graphicxpakket een optie dvips of pdftex doorgeven
% in dat geval oet je ze ook aan iiiscriptie doorgeven, dus bijvoorbeeld
% \usepackage[dvips]{graphicx}
% \usepackage[dvips]{iiiscriptie}
\usepackage{graphicx}
\usepackage{iiirapport}
\usepackage[none]{hyphenat}
\usepackage{xcolor}

%Nuttig pakket voor URL's
\usepackage{url}
\def\latex{$\mathrm{L\!\!^{{}_{\scriptstyle A}} \!\!\!\!\!\;\; T\!_{\displaystyle E} \!
X}$}
%
%Invullen velden voor titelpagina.
%
\departement{Faculteit Ingenieurswetenschappen en Architectuur}
\deptadres{Valentin Vaerwijckweg 1 - 9000 Gent}
\studiejaar{3e Bachelor Informatica}
\soortrapport{
Verslag voor bachelorproef (sprint 1)
}
\title{Verkeerscentrum}
\author{
\begin{tabular}{ll}
Groep 2 & Mike BRANTS\\
&Tobias VAN DER PULST\\
&Thomas VANDE WEGHE\\
&Simon VERMEERSCH\\
\end{tabular}
}
\begin{document}
\maketitle
\pagenumbering{roman}
\tableofcontents
\addcontentsline{toc}{chapter}{Inhoudsopgave}
\pagenumbering{arabic}
\chapter{Behoefteanalyse}
%Het doel van dit project is het opzetten van een database voor de verkeersgegevens van bepaalde %trajecten in Gent. In de eerste plaats worden gegevens opgehaald van bekende %verkeersinformatie-providers. Daarna zal de opgehaalde data in een database opgeslagen worden. De %bedoeling is om op deze manier de informatie van verschillende providers kwalitatief met elkaar te %vergelijken.
\section{Beschrijving project}
Het Mobiliteitsbedrijf van de stad gent is sinds 2014 bezig met het opzetten van een regionaal verkeerscentrum. Het is de bedoeling dat op termijn het verkeer in de regio constant gemonitord wordt, op semi-automatische basis op normale werkdagen en bemand tijdens piekmomenten en evenementen. Tijdens de week is het de bedoeling dat onverwachte incidenten, calamiteiten of significante verhogingen van de reistijden automatisch gesignaleerd worden aan de\\ verantwoordelijke, die dan de nodige acties kan ondernemen. De gegevens zouden ook constant beschikbaar zijn voor het publiek via een website, sociale media en open data. Op die manier kunnen mensen de beste route en het beste moment kiezen om hun verplaatsingen te maken in de regio.
\section{Functionaliteiten}
%\subsection{Basis}
\begin{enumerate}
\item Ophalen van kwalitatieve en vergelijkbare data bij verschillende bronnen
\item Real-time overzicht van de verkeersdruke op vooraf vastgelegde trajecten
\item Analyse op basis van opgehaalde data
\item Aanbieden van gegevens aan externen via REST API
\item Kwaliteitscontrole van de verkregen data
%\end{enumerate}
%\subsection{Extra}
%\begin{enumerate}
\item Platform gelinkt met sociale media om snelle communicatie aan te bieden
\item Meldingen genereren wanneer reistijden overschreden worden
\item Bepalen van de oorzaak van een vertraging
\end{enumerate}
\section{Use Case}
\diagram{UseCaseDiagram1}{Use Case}
Er zijn drie actoren aan het werk. In de eerste plaats is er een timer, deze zal een trigger sturen naar het programma zodat data afkomstig van de verschillende providers opgehaald wordt. Verder is er nog een API-gebruiker, dit is een persoon die data kan ophalen uit de database gebruik makend van de REST API. Als laatste is er nog een administrator, hij kan routes toevoegen aan de database zodat ook van deze routes data wordt opgehaald.
\section{Functieanalyse van de omgeving}
\begin{enumerate}
	\item Gebruikers
	\begin{enumerate}
		\item Ontwikkelaar
		\item Adminstrator
		\item Operator in het verkeerscentrum
	\end{enumerate}
\item Doelstellingen\\
De doelstellingen representeren de product backlog en ze bevatten de taken die het systeem moet kunnen.
\begin{enumerate}
	\item Basisfunctionaliteit
		\begin{enumerate}
			\item Data ophalen uit meerdere bronnen
			\begin{enumerate}
				\item Google Maps
				\item Here
				\item Waze
				\item TomTom
				\item Coyote
			\end{enumerate}
			\item Databank cre\"eren en opvullen met opgehaalde data
		\end{enumerate}
	\item API met verschillende parameters
	\begin{enumerate}
		\item Periode
		\item Traject
		\item Leverancier
		\item Vertraging
	\end{enumerate}
	\item Dashboard
	\begin{enumerate}
		\item Grafische opbouw van de GUI
		\item Grafieken/Tabellen genereren
		\item Grafische weergave op kaart
		\item Selecteren parameters gebruik makend van API
	\end{enumerate}	
	\item Kwaliteitscontrole
	\begin{enumerate}
		\item Procedures via MySQL
		\item Grafieken/Tabellen genereren
	\end{enumerate}
\end{enumerate}
\end{enumerate}
\chapter{Ontwerp}
\section{Functioneel ontwerp}
%\textcolor{red}{\textit{. Functioneel ontwerp: beschrijft de taken en de
%verantwoordelijkheden van de mensen
%ïƒž Wie verzorgt de invoer? Wanneer gebeurt dit?
%Hoe gebeurt dit? }}
Er zijn 2 types gebruikers in het systeem. Enerzijds zijn er de API-gebruikers, zij hebben de mogelijkheid om data uit de API op te vragen en eventueel verder te verwerken. Anderzijds is er een administrator, deze gebruiker kan routes toevoegen aan het systeem.
\section{Technisch ontwerp (Tobias)}
\subsection{Hardware}
Tijdens de ontwikkelingsfase zal beroep gedaan worden op de servers van de UGent.
\subsection{Paketten}
Dit project wordt uitgewerkt in Java metbehulp van het Java EE (\textit{Enterprise Edition}) \textit{framework}. Dit framework omvat verschillende technologie\"en die in dit project gebruikt worden. 
\begin{enumerate}	
	\item JavaServer Faces (JSF) 2.2
	\item Context and Dependency Injection for Java 1.1
	\item Enterprise JavaBeans (EJB) 3.2
	\item Java Persistence API (JPA) 2.1
	\item Java Transaction API (JTA) 1.2
	\item Java API for RESTful Web Services (JAX-RS) 2.0
\end{enumerate}
Dit wordt aangevuld met enkele Glassfish voorzieningen.
\begin{enumerate}
	\item Java Naming and Directory Interface (JNDI)
	\item Java Database Connection (JDBC) connection pools
\end{enumerate}
Hieronder zal elk deel uitgebreid behandeld worden.
\subsubsection{JSF}
Deze technologie laat toe webpaginas te genereren op basis van data in de applicatie. Deze data wordt aangeleverd via \textit{backing beans}. Over de jaren is JSF uitgebreid met Ajax ondersteuning alsook luisteraars bij data wijzigingen. Dit alles laat toe een zeer flexibele, \textit{responsive} interface te maken voor de gebruikers.
\subsubsection{Contexts and Dependency Injection}
Alle beans verwachten diensten waarvan zijzelf afhangen. Zo wordt bij de Data Access Beans (DAO) gebruik gemaakt van de EntityManager voor interactie met de databank. Bij de TrafficDataDownloader wordt dan weer de context van de applicatieserver verwacht om andere beans op te vragen. Al deze diensten zijn niet de verantwoordelijkheid van deze individuele beans maar van de applicatieserver. Deze laatste gedraagt zich als \textit{injector} en zal alle vereiste \textit{services} (\textit{dependencies}) plaatsen in de beans aan de hand van annotaties en objecttypes.
\subsubsection{EJB}
JavaBeans zijn door software beheerde modulaire bouwblokken. In deze beans wordt de \textit{business logic} voor een Enterprise Applicatie verwerkt. De grootste kenmerken voor deze beans zijn hun modulariteit, onafhankelijkheid van elkaar en schaalbaarheid.\\\\
\textit{Modulariteit}\\
Iedere module (JavaBean) in het project is uitwisselbaar met een nieuwe module. Dit is aan te passen in een extern properties bestand. Zo kan op ieder moment bijvoorbeeld een leverancier worden toegevoegd, een database worden vervangen door een andere of een nieuwe \textit{web service} worden toegevoegd.\\\\
\textit{Onafhankelijkheid}\\
Alle beans zijn onafhankelijk. Alle objecten die voorkomen in meerdere beans (zoals interfaces) zijn gebundeld in een gemeenschappelijke bibliotheek. Hierdoor zullen beans geen enkele invloed ondervinden wanneer een andere bean wijzigt.\\\\
\textit{Uitbreidbaarheid}\\
De modules zijn niet enkel onafhankelijk, maar hebben eveneens geen vaste relatie met de locatie waar ze werken. Zo kan een \textit{database bean} op een andere server staan dan de \textit{analyser bean}. De enige vereiste hiervoor is dat JNDI van de ene server gelinkt is aan de JNDI van de andere server. De beans zullen hun parameters en teruggeefwaardes steeds serialiseren en doorsturen naar de zogenaamde \textit{remote bean}.
\subsubsection{JPA}
De Java variant voor Object Relational Mapping (ORM) laat toe de gegevens in een databank rechtstreeks af te beelden op objecten door middel van annotaties. Deze manier van interactie met de databank laat een zeer eenvoudige werking toe. Het zal echter niet de performantie van handmatige SQL-commando's evenaren.
\subsubsection{JTA}
Deze API start (zonder enige configuratie) steeds een transactie bij het aanroepen van een functie in een \textit{managed bean}. Indien die functie er fout zou opwerpen zal een rollback gebeuren tot de toestand vlak voor de aanroep van de desbetreffende functie. In het project wordt op deze API vertrouwd voor opslag van gegevens in de databank. Bij een fout zal de dataopslag voor dat bepaalde interval niet plaatsvinden. Hierna zal de applicatie echter wel blijven verderwerken.
\subsubsection{JAX-RS}
Deze API laat toe om services aan te bieden volgens het Representational State Transfer (REST) patroon. In dit project wordt het gebruikt om de API uit te werken.
\subsubsection{JNDI}
Deze technologie laat toe data of objecten op te vragen via naam. Voor dit project werd de link naar de bronbestanden, de link naar de JDBC Connection Pool en de link naar alle beans opgenomen in JNDI.
\subsubsection{JDBC Connection Pools}
Een Connection Pool houdt een \textit{cache} van connecties naar een welbepaalde databank bij en maakt deze beschikbaar aan de applicaties van de applicatieserver. Dit alles zorgt voor een hogere effici\"entie want de connecties worden behouden en herbruikt. Hiernaast wordt er ook een hogere veiligheid verondersteld, de connectieparameters zijn namelijk niet langer in de applicatie zelf aanwezig.
\section{Software ontwerp}
\subsection{Dataproviders}
\subsubsection{Google Maps}
Om de reistijden die Google Maps heeft verzameld te kunnen raadplegen, moet er gebruik gemaakt worden van de Google Maps Distance Matrix API \\(https://developers.google.com/maps/documentation/distance-matrix/) . In de URL kunnen verschillende start- en eindpunten worden meegegeven, alsook of het antwoord json dan wel XML moet teruggeven. Hou er wel rekening mee dat er voor elke combinatie van start- en eindpunt die worden meegegeven, een reistijd wordt opgenomen in het resultaat. Als er dus drie startpunten en drie eindpunten worden meegegeven, zal het resultaat een 3X3-matrix zijn. Dit komt dan ook overeen met negen aanvragen naar de API. De limiet per URL is een 10X10-matrix.\\\\
Om effectief de actuele reistijden te verkrijgen moeten de parameters \\â€˜traffic\_modelâ€™ en â€˜departure\_time=nowâ€™ ook zeker in de URL opgenomen worden. Om deze aanvragen te kunnen doen moet er een sleutel aangevraagd worden, die gekoppeld wordt aan het project. Met een gratis sleutel kunnen 2500 elementen per dag opgevraagd worden (het aantal elementen is gelijk aan het aantal startpunten vermenigvuldigd met het aantal eindpunten). Indien dit overschreden wordt zal er per schijf van 1000 extra elementen 0.5 dollar aangerekend worden.\\\\
Indien je voor de 34 routes om de 5 minuten de reistijden opvraagt en dit 18u per dag, dan zit je al aan meer dan 7300 aanvragen per dag. Er rekening mee houdend dat eventuele tussenpunten het aantal aanvragen bij deze API nog eens heel sterk doen oplopend, mag duidelijk zijn dat het gratis model niet zal volstaan. Er kan overgeschakeld worden het â€˜Google Maps APIâ€™s Premium Planâ€™ zodat er tot 100 000 aanvragen per dag gedaan kunnen worden.\\

\subsubsection{Here}
Here stelt reistijden ter beschikking via zijn Routing API \\(https://developer.here.com/rest-apis/documentation/routing). In de URL geef je aan of je json of XML als antwoord wilt en kan je een route meegeven door de geoco\"ordinaten in te stellen voor start- en eindpunt en eventuele tussenpunten mee te geven. Verder moet voor de toepassing die hier ontworpen wordt steeds gekozen worden voor de kortste route in plaats van de snelste en moet er rekening gehouden worden met het huidige verkeer. Op deze manier zal steeds actuele info over een vaste route worden teruggeven.\\\\
Om de API van Here te kunnen gebruiken moeten er twee sleutels aangevraagd worden die gekoppeld worden aan de applicatie. De eerste 90 dagen kan dit gratis en mogen er tot 100 000 aanvragen per maand gedaan worden. Als je de 34 routes om de vijf minuten wil opvragen komen je echter al aan meer dan 220 000 aanvragen per maand en zou je sowieso een betalende formule nodig hebben. Om tot 275 000 aanvragen per maand te kunnen doen moet er ingestapt worden in het standaard plan dat 99 euro per maand kost.\\
\subsection{Structuur van de data (API)}
De REST API geeft info terug uit de database, hier heb je de keuze uit drie opties: routes, routedata en providers. Wanneer je hier aanvragen naar doet krijg je gegevens uit de database terug. In de komende secties wordt een korte toelichting gegeven per optie, gevolg door een voorbeeld van aanvraag en antwoord in JSON-formaat. Er is een online API beschikbaar waarin je meer informatie kan terugvinden, hieronder krijg je alvast een kort overzicht.

\subsubsection{Routes}
De routes zijn de trajecten waar realtime data van opgeroepen wordt. Indien je geen parameters meegeeft zullen naam, id en tussenpunten teruggegeven worden. In de toekomst zal het ook mogelijk zijn om routes toe te voegen via de API.\\

\noindent\rule[0.5ex]{\linewidth}{1pt}
\textbf{Vraag}\\
\textit{Patroon}\\
\textbf{GET} http://verkeer-2.bp.tiwi.be/api/v2/routes/id\\\\
\textit{Voorbeeld}\\
\textbf{GET} http://verkeer-2.bp.tiwi.be/api/v2/routes/1,2,3\\
\noindent\rule[0.5ex]{\linewidth}{1pt}

\noindent\rule[0.5ex]{\linewidth}{1pt}
\textbf{Antwoord}\\
\textit{Voorbeeld}
\begin{verbatim}[
 {
    "name": "R4 Zelzate",
    "id": 2,
    "geolocations": [
    {
        "latitude": 51.192226,
        "name": "Zelzate",
        "longitude": 3.776342
    },
    {
        "latitude": 51.086447,
        "name": "Gent",
        "longitude": 3.672188
    }
   ]
 }
]\end{verbatim}
\noindent\rule[0.5ex]{\linewidth}{1pt}
\subsubsection{RouteData}
De routedata is de opgehaalde data per route van de verschillende providers op verschillende tijdstippen. Je kan kiezen voor welke routes je data wil terugkrijgen, tevens zal je begin- en eindpunt kunnen instellen. Dit laatste is nuttig om data in een bepaald interval terug te krijgen. Het is ook mogelijk om in plaats van twee tijdstippen enkel \textit{current} op te geven, in dat geval wordt de actuele informatie getoond.\\\\ 


\noindent\rule[0.5ex]{\linewidth}{1pt}
\textbf{Vraag}\\
\textit{Patroon}\\
\textbf{GET} http://verkeer-2.bp.tiwi.be/api/v2/routes/id/data/timeStart/timeEnd\\\\
\textit{Voorbeeld}\\
\textbf{GET} http://verkeer-2.bp.tiwi.be/api/v2/routes/1,2,3/data/1456761535931/huidig tijdstip/\\\\
\textit{Voorbeeld (Actueel)}\\
\textbf{GET} http://verkeer-2.bp.tiwi.be/api/v2/routes/1,2,3/data/current/\\
\noindent\rule[0.5ex]{\linewidth}{1pt}

\noindent\rule[0.5ex]{\linewidth}{1pt}
\textbf{Antwoord}
\textit{Voorbeeld}
\begin{verbatim}[
 {
    "data": [
      {
       "duration": 753,
       "distance": 14677,
       "provider": "GoogleMaps",
       "timestamp": "1456761535931"
      },
      {
       "duration": 681,
       "distance": 14685,
       "provider": "Here",
       "timestamp": "1456761535931"
      }
    ],
    "name": "R4 Zelzate",
    "id": 2,
    "geolocations": [
     {
        "latitude": 51.192226,
        "name": "Zelzate",
        "longitude": 3.776342
     },
     {
        "latitude": 51.086447,
        "name": "Gent",
        "longitude": 3.672188
     }
    ]
 }
]\end{verbatim}
\noindent\rule[0.5ex]{\linewidth}{1pt}
\subsubsection{Providers}
Het is mogelijk om via de REST API alle providers op te vragen, dit kan handig zijn om in bijvoorbeeld RouteData te gebruiken als parameter.\\
\noindent\rule[0.5ex]{\linewidth}{1pt}
\textit{Patroon}\\
\textbf{GET} http://verkeer-2.bp.tiwi.be/api/v2/providers\\\\
\textit{Voorbeeld}\\
\textbf{GET} http://verkeer-2.bp.tiwi.be/api/v2/providers\\
\noindent\rule[0.5ex]{\linewidth}{1pt}
\noindent\rule[0.5ex]{\linewidth}{1pt}
\begin{verbatim}
[
 "Here",
 "GoogleMaps"
]
\end{verbatim}
\noindent\rule[0.5ex]{\linewidth}{1pt}
\subsubsection{Parameters}
Er zijn 2 types parameters die je kan meegeven op het einde van je URL: velden en providers. In velden kan je beslissen wat weergegeven moet worden in het antwoord en bij provider kan je ervoor kiezen om enkel data van bepaalde providers weer te geven.\\
\noindent\rule[0.5ex]{\linewidth}{1pt}
\textit{Voorbeeld}\\
?fields=route.name,route.id,route.geolocations\&provider=GoogleMaps,Here\\
\noindent\rule[0.5ex]{\linewidth}{1pt}
\subsection{Databank}
De database bestaat uit drie tabellen. RouteData is op termijn de grootste tabel, hierin worden alle opgehaalde gegevens bewaard. In routes staan alle trajecten waarvan data zal worden opgehaald. Deze routes bestaan uit geolocaties die het traject bepalen.
\diagram{database}{Databank}
\subsection{Klassendiagram}
In dit onderdeel vindt u drie klassendiagrammen, al kan je het in dit geval ook interfacediagrammen noemen. Om te beginnen is er een diagram voor de basiscomponenten, de meest elementaire klassen in het systeem. Deze klassen vormen ook de database. Hierna komt het diagram van het gegevensbeheer, deze bevat de samenwerking van klassen die data ophalen en verwerken. Als laatste, maar daarom niet minder belangrijk, vindt u de BeanFactory. Dit diagram bevat slechts \'e\'en klasse die de klassen uit diagram 3 zal beheren.
\diagram{Interface1}{Basiscomponenten/Database}
\diagram{Interface3}{Gegevensbeheer}
\diagram{Interface2}{BeanFactory}
\subsection{Verantwoordelijkheid per klasse}
\begin{tabular}{ | l | p{6.5cm}| }
	\hline
	\textbf{Klasse} & \textbf{Verantwoordelijkheid} \\
	\hline
	Route & bevat informatie over een route \\
	\hline
	GeoLocation & bevat informatie over een locatie \\
	\hline
	RouteData & bevat verkeersinformatie van \'e\'en route, \'e\'en provider en dit op \'e\'en bepaald moment in de tijd \\
	\hline
	IgnoredPeriod & vertegenwoordigt periodes die genegeerd moeten woden tijdens het berekenen van gemiddelde reistijd per dag\\
	\hline
	[Object]Entity & deze klassen vertegenwoordigen bovenstaande objecten zodat ze in de database kunnen opgeslagen worden\\
	\hline
	HereSourceAdapter & omzetten van data, aangeboden door Here, naar RouteData\\	
	\hline
	GoogleMapsSourceAdapter & omzetten van data, aangeboden door Google Maps, naar RouteData\\	
	\hline
	SourceManager & beheren van adapters\\	
	\hline
	TimerScheduler & automatische triggering voor ophalen nieuwe data\\	
	\hline
	TrafficDataDownloader & beheren van routes en geeft commando om routedata op te halen door\\	
	\hline
	TrafficDataDownstreamAnalyser & data afkomstig van SourceAdapters controleren op correctheid en nadien verdere acties ondernemen indien nodig\\		
	\hline
	BeanFactory & deze klasse zal dependency injection vertegenwoordigen in alle klassen \\	
	\hline
	GeneralDAO & verbinding vormen tussen core en database\\	
	\hline
	TrafficDataDAO & RouteData opslaan in de database\\	
	\hline
\end{tabular}
\subsection{Modules}
De volledige applicatie streeft naar de richtlijnen van een Line Of Business applicatie. 
\subsubsection{Flexibel en Uitbreidbaar}
Door gebruik te maken van Java EE, waarin de gehele applicatie in verschillende modules wordt opgedeeld, kunnen nieuwe modules eenvoudig afzonderlijk worden gecreÃ«erd en worden toegevoegd. 
\subsubsection{Onderhoudbaarheid}
Dit analysedocument bevat alle nodige informatie over de klasses en hun onderlinge relaties na sprint 1. Op het einde van de ontwikkelingsperiode zal een documentatie worden voorzien met alle nodige informatie voor andere ontwikkelaars die de applicatie zouden willen wijzigen of uitbreiden.
\subsubsection{Testbaarheid}
De verschillende componenten werden getest gebruik makend van unittests en integratietests.
\subsubsection{Late Binding}
Java EE biedt de mogelijkheid om een applicatie op te delen in verschillende modules die afzonderlijk van elkaar kunnen worden gecompileerd. Er werden twee DAOâ€™s voorzien zodat de algemene data over routes en de verkeersinformatie over de routes kunnen worden opgeslagen in twee verschillende databases. Zo zal na de ontwikkelingsperiode de verkeersinformatie waarschijnlijk worden opgeslagen in een NoSQL-database, omdat de hoeveelheid data enorm groot zal worden. 
\subsubsection{Parallelle ontwikkeling}
Door opdeling in modules, die Java EE aanbiedt, kunnen programmeurs afzonderlijk van elkaar code implementeren.
\subsubsection{Losse koppeling van objecten}
Modules kunnen eenvoudig worden ontkoppeld en worden vervangen door een andere. De BeanFactory, die de module-objecten aanbiedt, wordt eenvoudig geconfigureerd in een propertiesbestand. Zo kan eenvoudig een nieuwe DAO worden toegevoegd daar de link in het configuratiebestand te wijzigen naar een andere DAO. Zo kan bijvoorbeeld de manier van opslaan van data eenvoudig worden gewijzigd van een SQL-database naar een NoSQL-database.
\subsubsection{Crosscutting concerns (Logging)}
De manier van logging kan eenvoudig worden gewijzigd door het hierboven beschreven principe van losse koppeling. Voor logging werd ook een module voorzien die kan worden gewijzigd door de link aan te passen in het propertiesbestand bij de BeanFactory.
\subsection{Gegevensstroomdiagram}
\diagram{dataflow3}{Gegevensstroomdiagram}
\subsubsection{Downstream}
De data van de verschillende providers wordt opgehaald met behulp van de SourceAdapters, per provider bestaat er een adapterklasse die de ISourceAdapter interface implementeert. De verschillende adapters bevinden zich in de \\SourceManager-klasse. Vanuit de TrafficDataDownloader wordt data per route aangevraagd, de SourceManager zal deze aanvragen doorsturen aan elke adapter en de ontvangen data per adapter teruggeven aan de TrafficDataDownloader. Vervolgens passeert de data ook nog de TrafficDataDownstreamAnalyser die controleert of de data geldig is en eventueel meldingen genereert. Om af te sluiten wordt de data doorgegeven aan de TrafficDataDAO, deze klasse zorgt ervoor dat de data in de database terechtkomt. 
\subsubsection{Upstream}
De mogelijkheid bestaat om via API-aanvragen data uit de database te halen, dit gebeurt via de TrafficDataDAO die contact heeft met de database.
\subsection{Bestandsstructuur (Tobias)}
Het project is opgedeeld in verschillende beans die we hieronder behandelen.
\subsubsection{Logger}
Deze bean start tegelijk met de server en maakt logging naar een bestand (log.txt) mogelijk.
\subsubsection{TimerScheduler}
Deze bean start tegelijk met de server en stuurt triggers volgens het patroon dat opgegeven wordt aan de bean in een \textit{properties}-bestand. Deze timer wordt gecre\"eerd via Java EE TimerServices.
\subsubsection{TrafficDataDownloader}
De downloader staat in voor de connectie tussen de adapters en de DAO. Deze bean wordt getriggerd door de TimerScheduler.
\subsubsection{TrafficDataDownstreamAnalyser}
Deze analyzer staat in voor generatie van meldingen bij opmerkelijke data.
\subsubsection{GoogleMapsSourceAdapter/HereSourceAdapter}
Providers leveren nieuwe RouteData-objecten aan de applicatie. Deze data wordt verkregen via API-aanroepen.
\subsubsection{GeneralDAO}
De GeneralDAO houdt de routes bij die door de applicatie in de gaten worden gehouden. De verkregen data uit het programma wordt omhult in GeoLocationEntity en RouteEntity om deze compatibel te maken voor de achterliggende databank.
\subsubsection{TrafficDataDAO}
De TrafficDataDAO houdt alle data bij van de routes verkregen door de applicatie. De RouteData uit het programma wordt omhult in RouteDataEntity om deze compatibel te maken voor de achterliggende databank.
\subsubsection{GeneralDAONoDB/TrafficDataDAONoDB}
Dit zijn twee dummy-objecten die gebruikt kunnen worden voor tests zonder de echte databank te gebruiken.
\subsubsection{RESTAPI}
Deze bean bevat de API-service van het project.
\subsection{Tests}
\subsubsection{Databank}
De databank werd gedurende het ontwikkelingsproces getest via het principe van integratietesting. De data die in de database werd opgeslagen kwam overeen met de data die gestuurd werd naar de database.
\subsubsection{SourceAdapters}
De SourceAdapters werden getest aan de hand van unittests en later integratietesting in combinatie met de database. In de unittests werd nagekeken of excepties werden opgegooid bij verkeerde invoer. Het vergelijken van data in onze database met de data die op de sites van de providers staat werd manueel uitgevoerd.
\subsubsection{Sortering geolocaties}
In \'e\'en route zitten meerdere geolocaties om te verzekeren dat het gevolgde pad correct is. Om zeker te zijn dat de sortering van de locaties correct gebeurt werd een unittest geschreven.
\subsubsection{REST API}
De gegevens uit de database worden correct weergegeven via de REST API.
\subsubsection{GeoLocation}
In de klasse geolocation bestaan 2 variabelen om de co\"ordinaten te bepalen namelijk latitude en longitude. Deze moeten binnen bepaalde grenswaarden liggen, bijgevolg werd hiervoor een exceptie met bijkomende unittest geschreven.
\end{document}

