%Preambule met standaardinstellingen
\documentclass[ps,a4paper,oneside]{report}
%Noot: zorg ervoor dat Nederlandse woordsplitsing geactiveerd is.
\usepackage[dutch]{babel}
% Noot: je kan het graphicxpakket een optie dvips of pdftex doorgeven
% in dat geval oet je ze ook aan iiiscriptie doorgeven, dus bijvoorbeeld
% \usepackage[dvips]{graphicx}
% \usepackage[dvips]{iiiscriptie}
\usepackage{graphicx}
\usepackage{iiirapport}
\usepackage[none]{hyphenat}
\usepackage{xcolor}

%Nuttig pakket voor URL's
\usepackage{url}
\def\latex{$\mathrm{L\!\!^{{}_{\scriptstyle A}} \!\!\!\!\!\;\; T\!_{\displaystyle E} \!
X}$}
%
%Invullen velden voor titelpagina.
%
\departement{Faculteit Ingenieurswetenschappen en Architectuur}
\deptadres{Valentin Vaerwijckweg 1 - 9000 Gent}
\studiejaar{3e Bachelor Informatica}
\soortrapport{
Verslag voor bachelorproef (sprint 1)
}
\title{Verkeerscentrum}
\author{
\begin{tabular}{ll}
Groep 2 & Mike BRANTS\\
&Tobias VAN DER PULST\\
&Thomas VANDE WEGHE\\
&Simon VERMEERSCH\\
\end{tabular}
}
\begin{document}
\maketitle
\pagenumbering{roman}
\tableofcontents
\addcontentsline{toc}{chapter}{Inhoudsopgave}
\pagenumbering{arabic}
\chapter{Behoefteanalyse}
%Het doel van dit project is het opzetten van een database voor de verkeersgegevens van bepaalde %trajecten in Gent. In de eerste plaats worden gegevens opgehaald van bekende %verkeersinformatie-providers. Daarna zal de opgehaalde data in een database opgeslagen worden. De %bedoeling is om op deze manier de informatie van verschillende providers kwalitatief met elkaar te %vergelijken.
\section{Beschrijving project}
Het Mobiliteitsbedrijf van de stad gent is sinds 2014 bezig met het opzetten van een regionaal verkeerscentrum. Het is de bedoeling dat op termijn het verkeer in de regio constant gemonitord wordt, op semi-automatische basis op normale werkdagen en bemand tijdens piekmomenten en evenementen. Tijdens de week is het de bedoeling dat onverwachte incidenten, calamiteiten of significante verhogingen van de reistijden automatisch gesignaleerd worden aan de\\ verantwoordelijke, die dan de nodige acties kan ondernemen. De gegevens zouden ook constant beschikbaar zijn voor het publiek via een website, sociale media en open data. Op die manier kunnen mensen de beste route en het beste moment kiezen om hun verplaatsingen te maken in de regio.
\section{Functionaliteiten}
%\subsection{Basis}
\begin{enumerate}
\item Ophalen van kwalitatieve en vergelijkbare data bij verschillende bronnen
\item Real-time overzicht van de verkeersdruke op vooraf vastgelegde trajecten
\item Analyse op basis van opgehaalde data
\item Aanbieden van gegevens aan externen via REST Api
\item Kwaliteitscontrole van de verkregen data
%\end{enumerate}
%\subsection{Extra}
%\begin{enumerate}
\item Platform gelinkt met sociale media om snelle communicatie aan te bieden
\item Meldingen genereren wanneer reistijden overschreden worden
\item Bepalen van de oorzaak van een vertraging
\end{enumerate}
\section{Use Case}
\diagram{UseCaseDiagram1}{Use Case}
\section{Functieanalyse van de omgeving}
\begin{enumerate}
	\item Gebruikers
	\begin{enumerate}
		\item Ontwikkelaar
		\item Adminstrator
		\item Operator in het verkeerscentrum
	\end{enumerate}
\item Doelstellingen\\
De doelstellingen representeren onze product backlog en ze bevatten de taken die het systeem moet kunnen.
\begin{enumerate}
	\item Basisfunctionaliteit
		\begin{enumerate}
			\item Data ophalen uit meerdere bronnen
			\begin{enumerate}
				\item Google Maps
				\item Here
				\item Waze
				\item TomTom
				\item Coyote
			\end{enumerate}
			\item Databank cre\"eren en opvullen met opgehaalde data
		\end{enumerate}
	\item API met verschillende parameters
	\begin{enumerate}
		\item Periode
		\item Traject
		\item Leverancier
		\item Vertraging
	\end{enumerate}
	\item Dashboard
	\begin{enumerate}
		\item Grafische opbouw van de GUI
		\item Grafieken/Tabellen genereren
		\item Grafische weergave op kaart
		\item Selecteren parameters gebruik makend van API
	\end{enumerate}	
	\item Kwaliteitscontrole
	\begin{enumerate}
		\item Procedures via MySQL
		\item Grafieken/Tabellen genereren
	\end{enumerate}
\end{enumerate}
\end{enumerate}
\chapter{Ontwerp}
\section{Functioneel ontwerp}
\textcolor{red}{\textit{. Functioneel ontwerp: beschrijft de taken en de
verantwoordelijkheden van de mensen
 Wie verzorgt de invoer? Wanneer gebeurt dit?
Hoe gebeurt dit? }}
\section{Technisch ontwerp}
\subsection{Hardware}
\textcolor{red}{Tijdens de ontwikkelingsfase zal beroep gedaan worden op de servers van de UGent.
\subsection{Paketten}
\begin{enumerate}
	\item Java EE
	\item Php MyAdmin
\end{enumerate}
}
\section{Software ontwerp}
\subsection{Dataproviders}
\subsubsection{Google Maps}
Om de reistijden die Google Maps heeft verzameld te kunnen raadplegen, moet er gebruik gemaakt worden van de Google Maps Distance Matrix API \\(https://developers.google.com/maps/documentation/distance-matrix/) . In de URL kunnen verschillende start- en eindpunten worden meegegeven, alsook of het antwoord json dan wel XML moet teruggeven. Hou er wel rekening mee dat er voor elke combinatie van start- en eindpunt die worden meegegeven, een reistijd wordt opgenomen in het resultaat. Als er dus 3 startpunten en 3 eindpunten worden meegegeven, zal het resultaat een 3X3-matrix zijn. Dit komt dan ook overeen met 9 aanvragen naar de API. De limiet per URL is een 10X10-matrix.\\\\
Om effectief de actuele reistijden te verkrijgen moeten de parameters \\‘traffic\_model’ en ‘departure\_time=now’ ook zeker in de URL opgenomen worden. Om deze aanvragen te kunnen doen moet er een sleutel aangevraagd worden, die gekoppeld wordt aan het project. Met een gratis sleutel kunnen 2500 elementen per dag opgevraagd worden (het aantal elementen is gelijk aan het aantal startpunten vermenigvuldigd met het aantal eindpunten). Indien dit overschreden wordt zal er per schijf van 1000 extra elementen 0.5 dollar aangerekend worden.\\\\
Indien we voor onze 34 routes om de 5 minuten de reistijden gaan opvragen en dit 18u per dag, dan zitten we al aan meer dan 7300 aanvragen per dag. Er rekening mee houdend dat eventuele tussenpunten het aantal aanvragen bij deze API nog eens heel sterk doen oplopend, mag duidelijk zijn dat het gratis model niet zal volstaan. Er kan overgeschakeld worden het ‘Google Maps API’s Premium Plan’ zodat er tot 100 000 aanvragen per dag gedaan kunnen worden.\\

\subsubsection{Here}
Here stelt reistijden ter beschikking via zijn Routing API \\(https://developer.here.com/rest-apis/documentation/routing). In de URL geef je aan of je json of XML als antwoord wilt en kan je een route meegeven door de geoco\"ordinaten in te stellen voor start- en eindpunt en eventuele tussenpunten mee te geven. Verder moet voor de toepassing die hier ontworpen wordt steeds gekozen worden voor de kortste route in plaats van de snelste en moet er rekening gehouden worden met het huidige verkeer. Op deze manier zal steeds actuele info over een vaste route worden teruggeven.\\\\
Om de API van Here te kunnen gebruiken moeten er 2 sleutels aangevraagd worden die gekoppeld worden aan de applicatie. De eerste 90 dagen kan dit gratis en mogen er tot 100 000 aanvragen per maand gedaan worden. Als we onze 34 routes om de 5 minuten willen opvragen komen we echter al aan meer dan 220 000 aanvragen per maand en zouden we sowieso al een betalende formule nodig hebben. Om tot 275 000 aanvragen per maand te kunnen doen moet er ingestapt worden in het standaard plan dat 99 euro per maand kost.\\
\subsection{Structuur van de data (API)}
De REST API bestaat uit 3 categorie\"en: trajecten, routedata en providers. Wanneer je hier aanvragen naar doet krijg je gegevens uit de database terug. In de komende secties wordt een korte toelichting gegeven per categorie, gevolg door een voorbeeld van aanvraag en antwoord in JSON-formaat. \\Er is een online API beschikbaar waarin je meer informatie kan terugvinden, hieronder krijg je alvast een kort overzicht.

\subsubsection{Routes}
De routes zijn de trajecten waar realtime data van opgeroepen wordt. Er kan gekozen worden om naam, id en/of alle tussenpunten te tonen voor de trajecten, indien je geen parameters meegeeft zullen standaard naam, id en tussenpunten teruggegeven worden. In de toekomst zal het ook mogelijk zijn om routes toe te voegen via de API.\\

\noindent\rule[0.5ex]{\linewidth}{1pt}
\textit{Patroon}\\
\textbf{GET} ../routes/id/?fields=route.name,route.id,route.geolocations\\\\
\textit{Voorbeeld}\\
\textbf{GET} ../routes/1,2,3/?fields=route.name,route.id,route.geolocations\\
\noindent\rule[0.5ex]{\linewidth}{1pt}

\noindent\rule[0.5ex]{\linewidth}{1pt}
\textit{Voorbeeld}
\begin{verbatim}[
 {
    "name": "R4 Zelzate",
    "id": 2,
    "geolocations": [
    {
        "latitude": 51.192226,
        "name": "Zelzate",
        "longitude": 3.776342
    },
    {
        "latitude": 51.086447,
        "name": "Gent",
        "longitude": 3.672188
    }
   ]
 }
]\end{verbatim}
\noindent\rule[0.5ex]{\linewidth}{1pt}
\subsubsection{RouteData}
De routedata is de opgehaalde data per route van de verschillende providers op verschillende tijdstippen. Je kan kiezen voor welke routes je data wil terugkrijgen, tevens zal je begin- en eindpunt kunnen instellen. Dit laatste is nuttig om data in een bepaald interval terug te krijgen. In de parameters heb je ook de mogelijkheid om de provider mee te geven, je kan er op deze manier voor zorgen dat enkel data van bepaalde providers getoond wordt.\\\\ 


\noindent\rule[0.5ex]{\linewidth}{1pt}
\textit{Patroon}\\
\textbf{GET} ../routes/id/data/timeStart/timeEnd/?fields=route.name,route.id,\\route.geolocations\&provider=provider.name\\\\
\textit{Voorbeeld}\\
\textbf{GET} ../routes/1,2,3/data/1456761535931/huidig tijdstip/?fields=route.name,
route.id,route.geolocations\&provider=GoogleMaps,Here\\
\noindent\rule[0.5ex]{\linewidth}{1pt}

\noindent\rule[0.5ex]{\linewidth}{1pt}
\textit{Voorbeeld}
\begin{verbatim}[
 {
    "data": [
      {
       "duration": 753,
       "distance": 14677,
       "provider": "GoogleMaps",
       "timestamp": "1456761535931"
      },
      {
       "duration": 681,
       "distance": 14685,
       "provider": "Here",
       "timestamp": "1456761535931"
      }
    ],
    "name": "R4 Zelzate",
    "id": 2,
    "geolocations": [
     {
        "latitude": 51.192226,
        "name": "Zelzate",
        "longitude": 3.776342
     },
     {
        "latitude": 51.086447,
        "name": "Gent",
        "longitude": 3.672188
     }
    ]
 }
]\end{verbatim}
\noindent\rule[0.5ex]{\linewidth}{1pt}
\subsubsection{Providers}
Het is mogelijk om via de REST Api alle providers op te vragen, dit kan handig zijn om in bijvoorbeeld RouteData te gebruiken als parameter.\\
\noindent\rule[0.5ex]{\linewidth}{1pt}
\textit{Patroon}\\
\textbf{GET} ../providers\\\\
\textit{Voorbeeld}\\
\textbf{GET} ../providers\\
\noindent\rule[0.5ex]{\linewidth}{1pt}
\noindent\rule[0.5ex]{\linewidth}{1pt}
\begin{verbatim}
[
 "Here",
 "GoogleMaps"
]
\end{verbatim}
\noindent\rule[0.5ex]{\linewidth}{1pt}
\textcolor{red}{\subsection{Databank}
Ik geloof dat er een optie is in SQL Developer om hiervan een mooie representatie te maken zoals: http://i.stack.imgur.com/Usrhr.png }
\subsection{Klassediagram}
\diagram{Interface1}{Basiscomponenten}
\diagram{Interface3}{Gegevensbeheer}
\diagram{Interface2}{BeanFactory}
\subsection{Verantwoordelijkheid per klasse}
\begin{tabular}{ | l | p{6.5cm}| }
	\hline
	\textbf{Klasse} & \textbf{Verantwoordelijkheid} \\
	\hline
	Route & bevat informatie over een route \\
	\hline
	GeoLocation & bevat informatie over een locatie \\
	\hline
	RouteData & bevat verkeersinformatie van \"e\"en route, \"e\"en provider en dit op \"e\"en bepaald moment in de tijd \\
	\hline
	IgnoredPeriod & vertegenwoordigt periodes die genegeerd moeten woden tijdens het berekenen van gemiddelde reistijd per dag\\
	\hline
	[Object]Entity & deze klassen vertegenwoordigen bovenstaande objecten zodat ze in de database kunnen opgeslagen worden\\
	\hline
	HereSourceAdapter & omzetten van data, aangeboden door Here, naar RouteData\\	
	\hline
	GoogleMapsSourceAdapter & omzetten van data, aangeboden door Google Maps, naar RouteData\\	
	\hline
	SourceManager & beheren van adapters\\	
	\hline
	TimerScheduler & automatische triggering voor ophalen nieuwe data\\	
	\hline
	TrafficDataDownstreamAnalyser & data afkomstig van SourceAdapters controleren op correctheid en nadien verdere acties ondernemen indien nodig\\	
	\hline
	? & data beschikbaar stellen aan de API\\	
	\hline
	BeanFactory & deze klasse zal dependency injection vertegenwoordigen in alle klassen \\	
	\hline
	GeneralDAO & verbinding vormen tussen core en database\\	
	\hline
	TrafficDataDAO & RouteData opslaan in de database\\	
	\hline
\end{tabular}
\subsection{Gegevensstroomdiagram}
\diagram{dataflows2}{Gegevensstroomdiagram}
De data van de verschillende providers wordt opgehaald met behulp van de SourceAdapters, per provider bestaat er een adapterklasse die de ISourceAdapter interface implementeert. De verschillende adapters bevinden zich in de \\SourceManager-klasse. Vanuit de TrafficDataManager wordt data per route aangevraagd, de SourceManager zal deze aanvragen doorsturen aan elke adapter en de ontvangen data teruggeven aan de TrafficDataManager. Om af te sluiten wordt de data doorgegeven aan de TrafficDataDAO, deze klasse zorgt ervoor dat de data in de database terechtkomt. De mogelijkheid bestaat om via Rest-aanvragen data uit de database te halen zoals hierboven reeds beschreven.
\textcolor{red}{\subsection{Bestandstructuur}
Iets over de splitings in beans denk ik dan?
\subsection{Test}
Adapters => Integration Testing\\
Enkel db kan goed getest worden?
}
\end{document}

