%Preambule met standaardinstellingen
\documentclass[ps,a4paper,oneside]{report}
%Noot: zorg ervoor dat Nederlandse woordsplitsing geactiveerd is.
\usepackage[dutch]{babel}
% Noot: je kan het graphicxpakket een optie dvips of pdftex doorgeven
% in dat geval oet je ze ook aan iiiscriptie doorgeven, dus bijvoorbeeld
% \usepackage[dvips]{graphicx}
% \usepackage[dvips]{iiiscriptie}
\usepackage{graphicx}
\usepackage{iiirapport}
\usepackage[none]{hyphenat}
\usepackage{xcolor}

%Nuttig pakket voor URL's
\usepackage{url}
\def\latex{$\mathrm{L\!\!^{{}_{\scriptstyle A}} \!\!\!\!\!\;\; T\!_{\displaystyle E} \!
X}$}
%
%Invullen velden voor titelpagina.
%
\departement{Faculteit Ingenieurswetenschappen en Architectuur}
\deptadres{Valentin Vaerwijckweg 1 - 9000 Gent}
\studiejaar{3e Bachelor Informatica}
\soortrapport{
Verslag voor bachelorproef (sprint 1)
}
\title{Verkeerscentrum}
\author{
\begin{tabular}{ll}
Groep 2 & Mike BRANTS\\
&Tobias VAN DER PULST\\
&Thomas VANDE WEGHE\\
&Simon VERMEERSCH\\
\end{tabular}
}
\begin{document}
\maketitle
\pagenumbering{roman}
\tableofcontents
\addcontentsline{toc}{chapter}{Inhoudsopgave}
\pagenumbering{arabic}
\chapter{Behoefteanalyse}
%Het doel van dit project is het opzetten van een database voor de verkeersgegevens van bepaalde %trajecten in Gent. In de eerste plaats worden gegevens opgehaald van bekende %verkeersinformatie-providers. Daarna zal de opgehaalde data in een database opgeslagen worden. De %bedoeling is om op deze manier de informatie van verschillende providers kwalitatief met elkaar te %vergelijken.
\section{Beschrijving project}
Het Mobiliteitsbedrijf van de stad gent is sinds 2014 bezig met het opzetten van een regionaal verkeerscentrum. Het is de bedoeling dat op termijn het verkeer in de regio constant gemonitord wordt, op semi-automatische basis op normale werkdagen en bemand tijdens piekmomenten en evenementen. Tijdens de week is het de bedoeling dat onverwachte incidenten, calamiteiten of significante verhogingen van de reistijden automatisch gesignaleerd worden aan de\\ verantwoordelijke, die dan de nodige acties kan ondernemen. De gegevens zouden ook constant beschikbaar zijn voor het publiek via een website, sociale media en open data. Op die manier kunnen mensen de beste route en het beste moment kiezen om hun verplaatsingen te maken in de regio.
\section{Functionaliteiten}
%\subsection{Basis}
\begin{enumerate}
\item Ophalen van kwalitatieve en vergelijkbare data bij verschillende bronnen
\item Real-time overzicht van de verkeersdruke op vooraf vastgelegde trajecten
\item Analyse op basis van opgehaalde data
\item Aanbieden van gegevens aan externen via REST API
\item Kwaliteitscontrole van de verkregen data
%\end{enumerate}
%\subsection{Extra}
%\begin{enumerate}
\item Platform gelinkt met sociale media om snelle communicatie aan te bieden
\item Meldingen genereren wanneer reistijden overschreden worden
\item Bepalen van de oorzaak van een vertraging
\end{enumerate}
\section{Use Case}
\diagram{UseCaseDiagram1}{Use Case}
Er zijn drie actoren aan het werk. In de eerste plaats is er een timer, deze zal een trigger sturen naar het programma zodat data afkomstig van de verschillende providers opgehaald wordt. Verder is er nog een API-gebruiker, dit is een persoon die data kan ophalen uit de database gebruik makend van de REST API. Als laatste is er nog een administrator, hij kan routes toevoegen aan de database zodat ook van deze routes data wordt opgehaald.
\section{Functieanalyse van de omgeving}
\begin{enumerate}
	\item Gebruikers
	\begin{enumerate}
		\item Ontwikkelaar
		\item Adminstrator
		\item Operator in het verkeerscentrum
	\end{enumerate}
\item Doelstellingen\\
De doelstellingen representeren de product backlog en ze bevatten de taken die het systeem moet kunnen.
\begin{enumerate}
	\item Basisfunctionaliteit
		\begin{enumerate}
			\item Data ophalen uit meerdere bronnen
			\begin{enumerate}
				\item Google Maps
				\item Here
				\item Waze
				\item TomTom
				\item Coyote
			\end{enumerate}
			\item Databank cre\"eren en opvullen met opgehaalde data
		\end{enumerate}
	\item API met verschillende parameters
	\begin{enumerate}
		\item Periode
		\item Traject
		\item Leverancier
		\item Vertraging
	\end{enumerate}
	\item Dashboard
	\begin{enumerate}
		\item Grafische opbouw van de GUI
		\item Grafieken/Tabellen genereren
		\item Grafische weergave op kaart
		\item Selecteren parameters gebruik makend van API
	\end{enumerate}	
	\item Kwaliteitscontrole
	\begin{enumerate}
		\item Procedures via MySQL
		\item Grafieken/Tabellen genereren
	\end{enumerate}
\end{enumerate}
\end{enumerate}
\chapter{Ontwerp}
\section{Functioneel ontwerp}
%\textcolor{red}{\textit{. Functioneel ontwerp: beschrijft de taken en de
%verantwoordelijkheden van de mensen
% Wie verzorgt de invoer? Wanneer gebeurt dit?
%Hoe gebeurt dit? }}
Er zijn 2 types gebruikers in het systeem. Enerzijds zijn er de API-gebruikers, zij hebben de mogelijkheid om data uit de API op te vragen en eventueel verder te verwerken. Anderzijds is er een administrator, deze gebruiker kan routes toevoegen aan het systeem.
\textcolor{red}{\section{Technisch ontwerp (Tobias)}
\subsection{Hardware}
Tijdens de ontwikkelingsfase zal beroep gedaan worden op de servers van de UGent.
\subsection{Paketten}
\begin{enumerate}
	\item Java EE
	\item Glassfish
\end{enumerate}
}
\section{Software ontwerp}
\subsection{Dataproviders}
\subsubsection{Google Maps}
Om de reistijden die Google Maps heeft verzameld te kunnen raadplegen, moet er gebruik gemaakt worden van de Google Maps Distance Matrix API \\(https://developers.google.com/maps/documentation/distance-matrix/) . In de URL kunnen verschillende start- en eindpunten worden meegegeven, alsook of het antwoord json dan wel XML moet teruggeven. Hou er wel rekening mee dat er voor elke combinatie van start- en eindpunt die worden meegegeven, een reistijd wordt opgenomen in het resultaat. Als er dus 3 startpunten en 3 eindpunten worden meegegeven, zal het resultaat een 3X3-matrix zijn. Dit komt dan ook overeen met 9 aanvragen naar de API. De limiet per URL is een 10X10-matrix.\\\\
Om effectief de actuele reistijden te verkrijgen moeten de parameters \\‘traffic\_model’ en ‘departure\_time=now’ ook zeker in de URL opgenomen worden. Om deze aanvragen te kunnen doen moet er een sleutel aangevraagd worden, die gekoppeld wordt aan het project. Met een gratis sleutel kunnen 2500 elementen per dag opgevraagd worden (het aantal elementen is gelijk aan het aantal startpunten vermenigvuldigd met het aantal eindpunten). Indien dit overschreden wordt zal er per schijf van 1000 extra elementen 0.5 dollar aangerekend worden.\\\\
Indien je voor de 34 routes om de 5 minuten de reistijden opvraagt en dit 18u per dag, dan zit je al aan meer dan 7300 aanvragen per dag. Er rekening mee houdend dat eventuele tussenpunten het aantal aanvragen bij deze API nog eens heel sterk doen oplopend, mag duidelijk zijn dat het gratis model niet zal volstaan. Er kan overgeschakeld worden het ‘Google Maps API’s Premium Plan’ zodat er tot 100 000 aanvragen per dag gedaan kunnen worden.\\

\subsubsection{Here}
Here stelt reistijden ter beschikking via zijn Routing API \\(https://developer.here.com/rest-apis/documentation/routing). In de URL geef je aan of je json of XML als antwoord wilt en kan je een route meegeven door de geoco\"ordinaten in te stellen voor start- en eindpunt en eventuele tussenpunten mee te geven. Verder moet voor de toepassing die hier ontworpen wordt steeds gekozen worden voor de kortste route in plaats van de snelste en moet er rekening gehouden worden met het huidige verkeer. Op deze manier zal steeds actuele info over een vaste route worden teruggeven.\\\\
Om de API van Here te kunnen gebruiken moeten er 2 sleutels aangevraagd worden die gekoppeld worden aan de applicatie. De eerste 90 dagen kan dit gratis en mogen er tot 100 000 aanvragen per maand gedaan worden. Als je de 34 routes om de 5 minuten wil opvragen komen je echter al aan meer dan 220 000 aanvragen per maand en zou je sowieso een betalende formule nodig hebben. Om tot 275 000 aanvragen per maand te kunnen doen moet er ingestapt worden in het standaard plan dat 99 euro per maand kost.\\
\subsection{Structuur van de data (API)}
De REST API bestaat uit 3 categorie\"en: routes, routedata en providers. Wanneer je hier aanvragen naar doet krijg je gegevens uit de database terug. In de komende secties wordt een korte toelichting gegeven per categorie, gevolg door een voorbeeld van aanvraag en antwoord in JSON-formaat. Er is een online API beschikbaar waarin je meer informatie kan terugvinden, hieronder krijg je alvast een kort overzicht.

\subsubsection{Routes}
De routes zijn de trajecten waar realtime data van opgeroepen wordt. Er kan gekozen worden om naam, id en/of alle tussenpunten te tonen voor de trajecten, indien je geen parameters meegeeft zullen standaard naam, id en tussenpunten teruggegeven worden. In de toekomst zal het ook mogelijk zijn om routes toe te voegen via de API.\\

\noindent\rule[0.5ex]{\linewidth}{1pt}
\textit{Patroon}\\
\textbf{GET} ../routes/id/?fields=route.name,route.id,route.geolocations\\\\
\textit{Voorbeeld}\\
\textbf{GET} ../routes/1,2,3/?fields=route.name,route.id,route.geolocations\\
\noindent\rule[0.5ex]{\linewidth}{1pt}

\noindent\rule[0.5ex]{\linewidth}{1pt}
\textit{Voorbeeld}
\begin{verbatim}[
 {
    "name": "R4 Zelzate",
    "id": 2,
    "geolocations": [
    {
        "latitude": 51.192226,
        "name": "Zelzate",
        "longitude": 3.776342
    },
    {
        "latitude": 51.086447,
        "name": "Gent",
        "longitude": 3.672188
    }
   ]
 }
]\end{verbatim}
\noindent\rule[0.5ex]{\linewidth}{1pt}
\subsubsection{RouteData}
De routedata is de opgehaalde data per route van de verschillende providers op verschillende tijdstippen. Je kan kiezen voor welke routes je data wil terugkrijgen, tevens zal je begin- en eindpunt kunnen instellen. Dit laatste is nuttig om data in een bepaald interval terug te krijgen. In de parameters heb je ook de mogelijkheid om de provider mee te geven, je kan er op deze manier voor zorgen dat enkel data van bepaalde providers getoond wordt.\\\\ 


\noindent\rule[0.5ex]{\linewidth}{1pt}
\textit{Patroon}\\
\textbf{GET} ../routes/id/data/timeStart/timeEnd/?fields=route.name,route.id,\\route.geolocations\&provider=provider.name\\\\
\textit{Voorbeeld}\\
\textbf{GET} ../routes/1,2,3/data/1456761535931/huidig tijdstip/?fields=route.name,
route.id,route.geolocations\&provider=GoogleMaps,Here\\
\noindent\rule[0.5ex]{\linewidth}{1pt}

\noindent\rule[0.5ex]{\linewidth}{1pt}
\textit{Voorbeeld}
\begin{verbatim}[
 {
    "data": [
      {
       "duration": 753,
       "distance": 14677,
       "provider": "GoogleMaps",
       "timestamp": "1456761535931"
      },
      {
       "duration": 681,
       "distance": 14685,
       "provider": "Here",
       "timestamp": "1456761535931"
      }
    ],
    "name": "R4 Zelzate",
    "id": 2,
    "geolocations": [
     {
        "latitude": 51.192226,
        "name": "Zelzate",
        "longitude": 3.776342
     },
     {
        "latitude": 51.086447,
        "name": "Gent",
        "longitude": 3.672188
     }
    ]
 }
]\end{verbatim}
\noindent\rule[0.5ex]{\linewidth}{1pt}
\subsubsection{Providers}
Het is mogelijk om via de REST API alle providers op te vragen, dit kan handig zijn om in bijvoorbeeld RouteData te gebruiken als parameter.\\
\noindent\rule[0.5ex]{\linewidth}{1pt}
\textit{Patroon}\\
\textbf{GET} ../providers\\\\
\textit{Voorbeeld}\\
\textbf{GET} ../providers\\
\noindent\rule[0.5ex]{\linewidth}{1pt}
\noindent\rule[0.5ex]{\linewidth}{1pt}
\begin{verbatim}
[
 "Here",
 "GoogleMaps"
]
\end{verbatim}
\noindent\rule[0.5ex]{\linewidth}{1pt}
\subsection{Databank}
De database bestaat uit 3 tabellen. RouteData is op termijn de grootste tabel, hierin worden alle opgehaalde gegevens bewaard. In routes staan alle trajecten waarvan data zal worden opgehaald. Deze routes bestaan uit geolocaties die het traject bepalen.
\diagram{database}{Databank}
\subsection{Klassendiagram}
In dit onderdeel vindt u 3 klassendiagrammen, al kan je het in dit geval ook interfacediagrammen noemen. Om te beginnen is er een diagram voor de basiscomponenten, de meest elementaire klassen in het systeem. Deze klassen vormen ook de database. Hierna komt het diagram van het gegevensbeheer, deze bevat de samenwerking van klassen die data ophalen en verwerken. Als laatste, maar daarom niet minder belangrijk, vindt u de BeanFactory. Dit diagram bevat slechts 1 klasse die de klassen uit diagram 3 zal beheren.
\diagram{Interface1}{Basiscomponenten/Database}
\diagram{Interface3}{Gegevensbeheer}
\diagram{Interface2}{BeanFactory}
\subsection{Verantwoordelijkheid per klasse}
\begin{tabular}{ | l | p{6.5cm}| }
	\hline
	\textbf{Klasse} & \textbf{Verantwoordelijkheid} \\
	\hline
	Route & bevat informatie over een route \\
	\hline
	GeoLocation & bevat informatie over een locatie \\
	\hline
	RouteData & bevat verkeersinformatie van \'e\'en route, \'e\'en provider en dit op \'e\'en bepaald moment in de tijd \\
	\hline
	IgnoredPeriod & vertegenwoordigt periodes die genegeerd moeten woden tijdens het berekenen van gemiddelde reistijd per dag\\
	\hline
	[Object]Entity & deze klassen vertegenwoordigen bovenstaande objecten zodat ze in de database kunnen opgeslagen worden\\
	\hline
	HereSourceAdapter & omzetten van data, aangeboden door Here, naar RouteData\\	
	\hline
	GoogleMapsSourceAdapter & omzetten van data, aangeboden door Google Maps, naar RouteData\\	
	\hline
	SourceManager & beheren van adapters\\	
	\hline
	TimerScheduler & automatische triggering voor ophalen nieuwe data\\	
	\hline
	TrafficDataDownloader & beheren van routes en geeft commando om routedata op te halen door\\	
	\hline
	TrafficDataDownstreamAnalyser & data afkomstig van SourceAdapters controleren op correctheid en nadien verdere acties ondernemen indien nodig\\		
	\hline
	BeanFactory & deze klasse zal dependency injection vertegenwoordigen in alle klassen \\	
	\hline
	GeneralDAO & verbinding vormen tussen core en database\\	
	\hline
	TrafficDataDAO & RouteData opslaan in de database\\	
	\hline
\end{tabular}
\subsection{Modules}
De volledige applicatie streeft naar de richtlijnen van een Line Of Business applicatie. 
\subsubsection{Flexibel en Uitbreidbaar}
Door gebruik te maken van Java EE, waarin de gehele applicatie in verschillende modules wordt opgedeeld, kunnen nieuwe modules eenvoudig afzonderlijk worden gecreëerd en worden toegevoegd. 
\subsubsection{Onderhoudbaarheid}
Dit analysedocument bevat alle nodige informatie over de klasses en hun onderlinge relaties na sprint 1. Op het einde van de ontwikkelingsperiode zal een documentatie worden voorzien met alle nodige informatie voor andere ontwikkelaars die de applicatie zouden willen wijzigen of uitbreiden.
\subsubsection{Testbaarheid}
De verschillende componenten werden getest gebruik makend van unittests en integratietests.
\subsubsection{Late Binding}
Java EE biedt de mogelijkheid om een applicatie op te delen in verschillende modules die afzonderlijk van elkaar kunnen worden gecompileerd. Er werden twee DAO’s voorzien zodat de algemene data over routes en de verkeersinformatie over de routes kunnen worden opgeslagen in twee verschillende databases. Zo zal na de ontwikkelingsperiode de verkeersinformatie waarschijnlijk worden opgeslagen in een NoSQL-database, omdat de hoeveelheid data enorm groot zal worden. 
\subsubsection{Parallelle ontwikkeling}
Door opdeling in modules, die Java EE aanbiedt, kunnen programmeurs afzonderlijk van elkaar code implementeren.
\subsubsection{Losse koppeling van objecten}
Modules kunnen eenvoudig worden ontkoppeld en worden vervangen door een andere. De BeanFactory, die de module-objecten aanbiedt, wordt eenvoudig geconfigureerd in een propertiesbestand. Zo kan eenvoudig een nieuwe DAO worden toegevoegd daar de link in het configuratiebestand te wijzigen naar een andere DAO. Zo kan bijvoorbeeld de manier van opslaan van data eenvoudig worden gewijzigd van een SQL-database naar een NoSQL-database.
\subsubsection{Crosscutting concerns (Logging)}
De manier van logging kan eenvoudig worden gewijzigd door het hierboven beschreven principe van losse koppeling. Voor logging werd ook een module voorzien die kan worden gewijzigd door de link aan te passen in het propertiesbestand bij de BeanFactory.
\subsection{Gegevensstroomdiagram}
\diagram{dataflow3}{Gegevensstroomdiagram}
\subsubsection{Downstream}
De data van de verschillende providers wordt opgehaald met behulp van de SourceAdapters, per provider bestaat er een adapterklasse die de ISourceAdapter interface implementeert. De verschillende adapters bevinden zich in de \\SourceManager-klasse. Vanuit de TrafficDataDownloader wordt data per route aangevraagd, de SourceManager zal deze aanvragen doorsturen aan elke adapter en de ontvangen data per adapter teruggeven aan de TrafficDataDownloader. Vervolgens passeert de data ook nog de TrafficDataDownstreamAnalyser die controleert of de data geldig is en eventueel meldingen genereert. Om af te sluiten wordt de data doorgegeven aan de TrafficDataDAO, deze klasse zorgt ervoor dat de data in de database terechtkomt. 
\subsubsection{Upstream}
De mogelijkheid bestaat om via API-aanvragen data uit de database te halen, dit gebeurt via de TrafficDataDAO die contact heeft met de database.
\textcolor{red}{\subsection{Bestandsstructuur (Tobias)}
Iets over de splitings in beans denk ik dan?
}
\subsection{Tests}
\subsubsection{Databank}
De databank werd gedurende het ontwikkelingsproces getest via het principe van integratietesting. De data die in de database werd opgeslagen kwam overeen met de data die gestuurd werd naar de database.
\subsubsection{SourceAdapters}
De SourceAdapters werden getest aan de hand van unittests en later integratietesting in combinatie met de database. In de unittests werd nagekeken of excepties werden opgegooid bij verkeerde invoer. Het vergelijken van data in onze database met de data die op de sites van de providers staat werd manueel uitgevoerd.
\subsubsection{Sortering geolocaties}
In \'e\'en route zitten meerdere geolocaties om te verzekeren dat het gevolgde pad correct is. Om zeker te zijn dat de sortering van de locaties correct gebeurt werd een unittest geschreven.
\subsubsection{REST API}
De gegevens uit de database worden correct weergegeven via de REST API.
\subsubsection{GeoLocation}
In de klasse geolocation bestaan 2 variabelen om de co\"ordinaten te bepalen namelijk latitude en longitude. Deze moeten binnen bepaalde grenswaarden liggen, bijgevolg werd hiervoor een exceptie met bijkomende unittest geschreven.
\end{document}

